# Generated by Django 3.2.5 on 2021-10-29 10:59

import django.db.models.deletion
from django.db import migrations, models

import artemisdb.artemisdb.fields.ltree


class Migration(migrations.Migration):
    dependencies = [
        ("artemisdb", "0024_user_email_lowercase"),
    ]

    operations = [
        # Add the 'ltree' extension to PostgreSQL. Only needed once.
        #
        # In prod/nonprod the normal DB user cannot create this extension so it needs to be manually created
        # via the DB admin user.
        migrations.RunSQL(
            sql="CREATE EXTENSION IF NOT EXISTS ltree;",  # If the extension is already created this does nothing
            reverse_sql=migrations.RunSQL.noop,  # Do nothing so that the non-admin DB user can reverse this migration
        ),
        migrations.CreateModel(
            name="Component",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("name", models.CharField(max_length=256)),
                ("version", models.CharField(max_length=32)),
                ("label", models.CharField(max_length=256, unique=True)),
            ],
        ),
        migrations.CreateModel(
            name="License",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("license_id", models.CharField(max_length=32, unique=True)),
                ("name", models.CharField(max_length=256)),
            ],
        ),
        migrations.CreateModel(
            name="Dependency",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("label", models.CharField(max_length=256)),
                ("path", artemisdb.artemisdb.fields.ltree.LtreeField(default=None, editable=False, null=True)),
                ("source", models.CharField(max_length=4096, null=True)),
                (
                    "component",
                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to="artemisdb.component"),
                ),
                (
                    "parent",
                    models.ForeignKey(
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="children",
                        to="artemisdb.dependency",
                    ),
                ),
                ("scan", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to="artemisdb.scan")),
            ],
        ),
        migrations.AddField(
            model_name="component",
            name="licenses",
            field=models.ManyToManyField(to="artemisdb.License"),
        ),
        migrations.AlterUniqueTogether(
            name="component",
            unique_together={("name", "version")},
        ),
        migrations.AddField(
            model_name="scan",
            name="sbom",
            field=models.BooleanField(default=False),
        ),
        # The SQL below is modified from the examples at:
        # https://github.com/peopledoc/django-ltree-demo/blob/master/demo/categories/sql/
        #
        # Used when we access the path directly
        migrations.RunSQL(
            sql="CREATE INDEX artemisdb_dependency_dependency_path ON artemisdb_dependency USING btree(path);",
            reverse_sql=migrations.RunSQL.noop,  # Index will drop when the table is dropped
        ),
        # Used when we access the path directly
        migrations.RunSQL(
            sql="CREATE INDEX artemisdb_dependency_path_gist ON artemisdb_dependency USING GIST(path);",
            reverse_sql=migrations.RunSQL.noop,  # Index will drop when the table is dropped
        ),
        # Make sure we cannot have a path where one of the ancestor is the row itself
        # (this would cause an infinite recursion)
        migrations.RunSQL(
            sql="ALTER TABLE artemisdb_dependency ADD CONSTRAINT check_no_recursion "
            "CHECK(index(path, label::text::ltree) = (nlevel(path) - 1));",
            reverse_sql=migrations.RunSQL.noop,  # Constraint will drop when the table is dropped
        ),
        # Function to calculate the path of any given dependency
        migrations.RunSQL(
            sql="""
CREATE OR REPLACE FUNCTION _update_dependency_path() RETURNS TRIGGER AS
$$
BEGIN
    IF NEW.parent_id IS NULL THEN
        NEW.path = NEW.label::ltree;
    ELSE
        SELECT path || NEW.label
          FROM artemisdb_dependency
         WHERE NEW.parent_id IS NULL or id = NEW.parent_id
          INTO NEW.path;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
""",
            reverse_sql="DROP FUNCTION IF EXISTS _update_dependency_path;",
        ),
        # function to update the path of the descendants of a dependency
        migrations.RunSQL(
            sql="""
CREATE OR REPLACE FUNCTION _update_descendants_dependency_path() RETURNS TRIGGER AS
$$
BEGIN
    UPDATE artemisdb_dependency
       SET path = NEW.path || subpath(artemisdb_dependency.path, nlevel(OLD.path))
     WHERE artemisdb_dependency.path <@ OLD.path AND id != NEW.id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
""",
            reverse_sql="DROP FUNCTION IF EXISTS _update_descendants_dependency_path;",
        ),
        # Calculate the path every time we insert a new dependency
        migrations.RunSQL(
            sql="""
DROP TRIGGER IF EXISTS dependency_path_insert_trg ON artemisdb_dependency;
CREATE TRIGGER dependency_path_insert_trg
               BEFORE INSERT ON artemisdb_dependency
               FOR EACH ROW
               EXECUTE PROCEDURE _update_dependency_path();
""",
            reverse_sql="DROP TRIGGER IF EXISTS dependency_path_insert_trg ON artemisdb_dependency;",
        ),
        # Calculate the path when updating the parent or the name
        migrations.RunSQL(
            sql="""
DROP TRIGGER IF EXISTS dependency_path_update_trg ON artemisdb_dependency;
CREATE TRIGGER dependency_path_update_trg
               BEFORE UPDATE ON artemisdb_dependency
               FOR EACH ROW
               WHEN (OLD.parent_id IS DISTINCT FROM NEW.parent_id
                     OR OLD.label IS DISTINCT FROM NEW.label)
               EXECUTE PROCEDURE _update_dependency_path();
""",
            reverse_sql="DROP TRIGGER IF EXISTS dependency_path_update_trg ON artemisdb_dependency;",
        ),
        # If the path was updated, update the path of the descendants
        migrations.RunSQL(
            sql="""
DROP TRIGGER IF EXISTS dependency_path_after_trg ON artemisdb_dependency;
CREATE TRIGGER dependency_path_after_trg
               AFTER UPDATE ON artemisdb_dependency
               FOR EACH ROW
               WHEN (NEW.path IS DISTINCT FROM OLD.path)
               EXECUTE PROCEDURE _update_descendants_dependency_path();
""",
            reverse_sql="DROP TRIGGER IF EXISTS dependency_path_after_trg ON artemisdb_dependency;",
        ),
    ]
